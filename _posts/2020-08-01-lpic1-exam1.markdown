---
layout: post
title:  "LPIC-1 Exam 1"
date:   2020-08-01 12:20:00 -0400
categories: IT reference
---
Exam 1  
1. System Architecture
2. Linux installation and package management
3. GNU and UNIX commands
4. Devices, filesystems and filesystem hierarchy

Exam 2  
5. Shells, scripting and data management
6. User interfaces and desktop
7. Manage user and group accounts and related system files
8. Essential system services
9. Networking fundamentals
10. Security

# System Architecture
**Boot the system**  
Legacy BIOS booting:  
   BIOS > MBR > Boot Loader > Kernel > OS  
UEFI booting:  
   UEFI > EFI Boot Loader > Kernel > OS  
At the GRUB menu, you can edit the config temporarily by pressing 'e'.  
   Linux line: specifies the kernel (central module of an OS)  
   Initrd line: specifies the ramdisk (temporary root fs loaded into mem during boot).  
Within the OS you can view this with `cat /proc/cmdline`  
Init is the first process run by a Linux system.  
You can view this by using `ps aux | head` and viewing PID 1.  
It is located at `/sbin/init`  
View kernel messages that are logged during system boot with `dmesg -T`  
To suppress boot messages use the 'quiet' kernel parameter.  
This can be added in the GRUB config file on line `GRUB_CMDLINE_LINUX_DEFAULT="quiet"`  

**Configuring Hardware**  
Udev is the device manager and handles events (such as loading firmware).  
This is done by tmpfs that is mounted to `/dev` on startup.  
Udev configuration is found at `/etc/udev/rules.d`  
Dbus is a framework that allows processes to talk to each other securely and reliably.  
Sysfs - virtual filesystem provided by the kernel.  
Shows information about kernel subsystems (hw devices, drivers, etc)  
Located at `/sys`  
Procfs - similar to sysfs but also shows processes and system info  
Located at `/proc`  
You can use /proc to change kernel parameters  
To view all the modules in use, use `lsmod`  
To enable a mod use `modprobe` to remove a mod use `rmmod`  
To view all PCI devices connected to the system, use `lspci`  
You can get more information by adding `-v`, `-vv`, or `-vvv`  

**Runlevels and boot targets**  
Number between 0 and 6 that determines the script that is executed at initialization  
Can be automatic or manual  
Varies by distribution  
```
0 - Halt (shutdown)  
1 - Single user mode  
2 - Multi-user, no network  
3 - Multi-user and network  
4 - Unused (customizable)  
5 - Runlevel3 + GUI  
6 - Reboot  
```
Script location is based on whether the system is running sysvinit or systemd  

Sysvinit  
inittab located at `/etc/inittab`  

Systemd  
System scripts located at `/etc/systemd/system`  
Package scripts located at `/usr/lib/systemd/system`  
System > Package as far as priority  
Uses 'targets' instead of runlevels:  
```
runlevel0.target, poweroff.target  
runlevel1.target, rescue.target  
runlevel2.target, runlevel4.target, multi-user.target  
runlevel5.target, graphical.target  
runlevel6.target, reboot.target  
emergency.target  
```
Emergency.target is similar to recovery mode on Windows. Lets you sign in as root to a terminal with only essential services loaded.  
Use `init` or `telinit` to change runlevels  
You can also use `sudo systemctl isolate reboot.target` to temporarily change runlevel  
To permanently change runlevel use `sudo systemctl enable multi-user.target`  

# Linux installation and package management
**Design hard disk layout**  
Filesystem Hierarchy Standard (FHS)  
Defines the directory structure in Linux.  
The root is designated with '/'  
`/boot` - files for booting the OS  
`/bin` - critical executable files (ls, cp, mount, etc)  
`/dev `- device files  
`/sbin` - similar to bin (programs run by sysadmin)  
`/etc` - configuration files  
`/home` - user's home directory  
`/lib `- program libraries  
`/media` - mount point for removable media  
`/usr` - utilities and applications  
`/var` - logs  
`/tmp` - temporary files  

**Install a boot loader**  
Boot loaders boot the system and run before the OS.  
They can be configured while using the OS.  
Boot loaders: LILO, GRUB Legacy, GRUB2  
To determine what version you're using, use `grub-probe --version`  
The config file is in `/boot/grub.cfg`  (in legacy systems it is menu.lst or grub.conf)  
Add default options that apply to all entries in grub at `/etc/default/grub`  
After you make changes you must use `update-grub` to generate the new files.  
To install grub to the MBR, use `sudo grub-install /dev/sda`  

**Manage shared libraries**  
Libraries are just shared, re-usable code to perform common tasks like writing a file to disk or sending files over the network.  
In order to use libraries, you must link them. Two types (static and dynamic)  
   Static - each application gets a copy of the library  
   Dynamic - each application points to the libraries they share  
Location of config file: `/etc/ld.so.conf`  
To update the linker bindings use `ldconfig`  
If you want to set one temporarily, you can use an environment variable `LD_LIBRARY_PATH`.  
Use export `<variable_name>=/home/user/lib/` (this gets cleared on logout)  
To view which libraries an object is linked to, use `ldd`  
For example, use `which ls` to find where an application is located, then `ldd /bin/ls` to show the dynamic link libraries.  

**Use Debian package management**  
dpkg is the debian package manager (low-level); it installs, upgrades, and removes software.  
apt is the high level package manager; does everything dpkg does but also can upgrade the system and resolve dependencies.  
Use `dpkg -l` to list all packages  
To update packages use, `sudo apt-get update`  
Configuration file for repositories located at `/etc/apt/sources.list`  
You can check dependencies for an app with `apt-cache depends apache2`  

**Use RPM and YUM package management**  
RPM = DPKG, YUM = APT  
Package management for Red Hat and Centos systems  
Located at `/etc/yum.conf`  
Sources directory located at `/etc/yum.repos.d`  
You can query RPM to find out what package a file belongs to:  
`rpm -qf /file/path`  
If that file gets removed, you can use `sudo rpm --verify <name of package>`  
This will return what files are missing.  
You can run this against the entire system with `sudo rpm -Va` (takes a long time)  

**Zypper and dnf**  
Zypper is specific to openSUSE  
List defined repos with `zypper repos` or `zypper lr`  
Install packages with `zypper in` and remove with `zypper remove --clean-deps <package>`  
DNF is the newest version of the YUM package manager for Redhat and Centos systems  
To find info on a package `dnf info <package>`  
To see installed apps `dnf list installed`  

**Linux as a virtualization guest**  
VM advantages:  
   Multiple OS on same computer  
   Can be cloned, backed up, easily restored  
   Easy to maintain and manage  
   Protects the host  
VM disadvantages:  
   Less efficient since hardware is accessed indirectly  
   Performance can be hindered by host  
Containers allow applications, libraries, dependencies, and files to be bundled together.  
Cloud-init - a set of scripts that execute when an instance (cloud vm) is started.  
Applies user data to your instances automatically.  

# GNU and UNIX commands
**Working on the command line**  
The shell is the text based interface that allows you to enter commands.  
The default is usually bash, but other common ones are zsh and csh.  
Environment variables can be viewed with `env`  
`SHELL=/bin/bash` tells you what shell is being used.  
`PATH=/home`... tells you where the system searches when executing commands.  
Command history is stored in `.bash_history` and the variable `$HISTFILE`  
Directories preceded by a '.' are hidden.  
To view all files including hidden files, use `ls -a`  
Environment variables are temporary and get reset when the shell is started unless you manually add them to the file `.bashrc`  
Set and unset can change the shell attributes and positional parameters.  
You can use `help set` for more info (no man page)  
There are 9 categories of man pages:  
  1. Executable programs or shell commands.  
  2. System calls  
  3. Library calls  
  4. Special files (/dev)  
  5. File formats and conventions  
  6. Games  
  7. Misc  # Shells, scripting and data management  
  8. Sysadmin commands (root)  
  9. Kernal routines  

Print system information with `uname -a`  

**Quoting, type and which**  
Quoting - hide characters from the shell. You can use \ for one character or ' ' for a line.  
To get information about commands, use `type` (if they are built-in or if there are binaries somewhere)  
To find where a command is in the path, use `which`  

**Process text streams using filters**  
How to manipulate text in a file or output from a command.  
Print the contents of a text file with `cat`.  
To remove sections from within a file use `cut` (uses char, fields, or bytes).  
To show a list of all usernames in the system, use `cut -d: -f1 /etc/passwd`  
`expand` is used to convert tabs in a file to 8 spaces; `unexpand` does the reverse.  
You can view tabs in a file with `cat -vet <filename>` (shown by '^I')  
To find the line | word | byte count use `wc`  
You can format a text file to wrap with `fmt`  
You can view the first 10 or last 10 lines of a file with `head` and `tail`  
To join two files, line by line that share a common field, use `join`  
To show a page by page version of a file, use `less`  
`nl` adds line numbers to a file.  
`od` dump files in octal format to your screen.  
`paste` is same as join, but does any line  
`pr` command cleans up a page for printing (adds date, name, page number)  
`sed` can perform complex operations on text  
`sed -e s/one/two`  will replace text with the one, with the word two  
`sort` can sort a file alphabetically (first character of each line)  
`split` splits a file into multiple pieces  
`tr -d` deletes characters  
`uniq` shows matching adjacent lines in a file  

**Cat and sums**  
`bzcat <filename.bz2>` will show the contents of compressed bunzip2 files  
`zcat <filename.gz>` will show the contents of compressed gzip files  
`xzcat <filename.xz>` will show the contents of compressed xz files  
`md5sum <filename>` used to verify a hash  
`sha256sum <filename>` and `sha512sum <filename>` do the same.  

**Basic file management**  
`cp file1 file2` copies files  
`~/` is a shortcut for the home directory  
`mkdir` makes a directory  
`mv file1 file2` moves a file  
`touch` creates a new file or updates the modified time to an existing file  
`rm` removes a file, -r deletes directories and contents (rmdir does the same)  
`file` reads a file's metadata  
`find . -name "file*"` searches the current directory for all files that begin with the word file  
With find, you can use -size or -mmin (minutes) to filter results.  
To create and extract archives use `tar cvf {newfile.tar} {file1} {file2} ...` and `tar xvf newfile.tar`  
Archives group files, but do not compress.  
`dd if=<input> of=<output> [options]` low level copy command to create backups  

**Use streams, pipes, and redirects**  
3 streams the shell uses: stdin-0, stdout-1 (>), stderr-2 (2>)  
You append with '>>', a single > will overwrite the file  
You redirect input with <  
If you use `sort << END`, it will take continuous input until the string END is entered  
Pipes | allow you to use the output of one command as the input to another command.  
`xargs` takes the output of one command (line by line) and uses it on the command that follows  
Example: `ls -1 | xargs wc` this takes every file from the ls command and finds the line count on each.  
You can redirect output to a file, while also watching the output as it appears using `tee`  

**Create, monitor, and kill processes**  
Kill a command with ctrl+c, or suspend with ctrl+c  
Once it's stopped you can let it run in the background with `bg`  
To bring it back to the front, you can use `fg`  
To run a script in the current shell (by default it spawns its own shell) use `source <script.sh>`  
If you use a `&` at the end of a command it will move it to the background  
You can use `nohup` to suppress messages  
Use `jobs` to show what processes are running  
You can view all processes with `ps aux` (this will show all processes group by user)  
kill <pid> will terminate a program or send signals if specified  

Signal Types:  
SIGINT interrupt signal (ctrl+c)  
SIGKILL kill signal (last resort)  
SIGSTOP pause signal (ctrl+z)  
SIGTERM termination signal (gentle)  

`killall <process name>` kills multiple processes with the same name  
`pkill` kills a process by name instead of PID  
`top` continually updating screen with processes and system info  
`uptime` shows uptime, logged in users, and load  
`free` RAM and swap usage  
`screen` allows you to have multiple terminals with active jobs  
`ctrl+a then d` detaches from the screen  
`screen -r` reattaches to the screen  
`a then c` will give a new window inside that screen  
`ctrl+a` and a will toggle the windows  

**Watch and tmux**  
`watch` run commands periodically and show the output on the same screen.  
`tmux` (terminal multiplexer) in one terminal open multiple windows but in the same screen  
ctrl+b switches to command mode, then you can use a variety of options  
ctrl+b then % will create a new window  
ctrl+b and arrow left or right will switch windows  
ctrl+d will close the window  
ctrl+b then c will create separate windows  
ctrl+b then n (next) or p (previous) to switch between full windows  
`tmux ls` can show all running sessions  

**Modify process execution priorities**  
Processes are given a "nice" time, which determines how much CPU time a process gets  
-20 is the highest, 19 is the lowest, 0 is the default  
`renice` can modify the nice value; by default the command puts 10 (lower than the default 0)  
Example: `sudo renice -5 -p <PID>`  

**Search text files using regular expressions**  
Symbols used in regex:  
| means or  
() means grouping  
$ means end of line  
^ means start of a line  
. means single character  
? match one or more of the preceding element  
\* match 0 or more occurrences  
\+ match 1 or more preceding element  
{n} the preceding element matches exactly n times  
{min,} or {min, max} further filter how many times an item must match  

GREP (globally search for a regular expression and print)  
Uses regex to search plain text  
3 types: grep, egrep, fgrep  
egrep allows you to use regex symbols without having to escape them (same as grep -E)  
fgrep search for a string without regex symbols  

**Basic vs extended regular expressions**  
In basic: ? + {} () don't have meaning and will be searched as is  
In extended: ? + {} () does have meaning and you have to escape the characters with \ in order to search as is.  

**Perform basic file editing operations using vi**  
Vi has two main modes: editing and command  
Editing mode is used for adding and removing text  
Command mode is for manipulating the file  
hjkl are used to move around  
You can search in command mode with / and press n to find the next result.  
dd deletes a line the cursor is on
p will paste a line after the current line a cursor is on  
P will paste a line before the current line a cursor is on  
yy to "yank" or copy a line  
Adding a number before a command will repeat the command  
For example: 3dd will delete 3 lines after the cursor.  
You can also do this with the movement keys.  
x will delete a character  
$ moves to the end of a line, ^ moves to the beginning of a line  
wq will write your changes and quit  
q! will quit without saving your changes  

**Other common editors**  
`emacs`  complex editor that competes with VIM; not installed by default.  
`nano`  lightweight and installed by default. Simple and easy to use  
`sudo update-alternatives` --config editor is used to set the system default editor  
To check your current editor you can echo $EDITOR  

# Devices, filesystems and filesystem hierarchy
**Create partitions and filesystems**  
`df` show file system disk space usage.  
`lsblk` can show partitions  
`sudo fdisk` tool for managing partitions  
Common commands for fdisk:  
p print disk info  
m show a list of commands available  
n for new partition  
p for primary, e for extended  
w write the changes to disk  
Another tool for partitioning is `parted`  
`mkpart > ext4 > <specify start and end>`  

MBR  
4 primary partitions, 2TB max size  

GPT  
UEFI, unlimited partitions  
Size and limits depend on OS  

Filesystems  
ext2 for small devices  
ext3 journaling
ext4 huge filesystems and files allowed newest  
reiserfs - legacy from 2001  
btrfs - snapshots checksums and pooling, auto defrag on mnt  
Use mkfs to make a filesystem  
Then mount the newly created filesystem to a partition:  
`sudo mount /dev/sdb1 /mnt/Photos`  

**Maintain the integrity of filesystems**  
`inode` object that describes a file or directory (attributes like last modified, owner, perms)  
You can run out of inodes and won't be able to create files despite free disk space.  
`ls -i <file or directory>` to view the inode  
`find . -inum <inode number> | xargs rm` This will let you delete a file that has special characters (like ^M)  
`df -i` shows inodes and usage  

`du -h` shows file usage in the current directory  
`fsck` checks and repairs issues with the filesystem  
You can't check a device that is mounted. Use umount first, then you can check.  
If you need to check root, reboot to rescue mode then run it.  

`sudo dumpe2fs /dev/device` gives information about the super block on a hard disk  
`sudo tune2fs -l /dev/device` This will list everything that can be set with tune2fs  

**xfs tools**  
`xfs_repair` attempts to repair corrupt XFS filesystems  
`xfs_fsr` defrag tool  
`xfs_db` examine or debug xfs filesystem (advanced command)  
`xfs_db /dev/xvdf1` then `sb`, then `p` to print  

**Control mounting and unmounting of filesystems**  
`mount` and `umount` can mount, unmount, and view filesystems  
You can also use `cat /proc/self/mounts`  
Filesystems are automatically mounted using a file `/etc/fstab`  
Example: You want to mount a separate partition for photos on boot  
`/dev/sdb1 /mnt/Photos ext2 defaults 0 0`  
You can then use `mount -a` This will mount everything in fstab that does NOT have `noauto` as the option.  
`fuser /path` shows which user is controlling a process.  
Then use `ps aux lgrep <number from fuser>` to show the owner  
`ps auxf` to show a tree version  

**Extra filesystem commands**  
`blkid` shows all filesystems with their uuid attached  
This is used in /etc/fstab  
Systemd has mount units located at `/lib/systemd/system` use `ls *.mount`  

**Manage disk quotas**  
Disk quotas limit the storage you can use.  
In fstab, add a new argument `usrquota` to enable user quotas on the disk  
Example `defaults,usrquota` then reboot  
`sudo apt-get install quota` then cd to the mount point and use `quotacheck -avugc` to initialize the disk  
`sudo edquota -u <username>` to edit the quota for a user  
`sudo quotaon /path` to enable quotas  
`dd if=/dev/zero of=test.file bs=1 count=5120` creates a test file that is 5120 bytes  
If you exceed the quota, you're given a 7 day grace period to remediate it.  
`sudo repquota /path` produces a report that shows quotas  

**Manage file permissions and ownership**  
When you use `ls -l`, you will see a line like this `-rwxrw-r--`  
The first character tells the file type: either - for file or d for directory  
The next 9 characters are grouped into 3 groups of 3 which represents (in order) user, group, other  
This can be represented by UGO  
To apply a permission change to all, use 'a'  
Each letter stands for a permission: rwx = read, write, execute  
Example: You want to change permissions for a user on a file  
`chmod u+rwx <filename>` gives read/write/execute for a user on a specified file  
You can specify multiple with a comma: `chmod u+rwx,g+rw,o+r <filename>`  

You can also specify permissions with numbers: r=4, w=2, x=1.  
So instead of typing `chmod u+rwx,g+rw,o+r <filename>` you can use `chmod 764 <filename>`  
```
rwx =7  
rw- =6  
r-x =5  
-r- =4  
-wx =3  
-w- =2  
--x =1  
--- =0  
```  

SETUID and SETGID  
Allows you to run the program as the owner, with owners permission  
`chmod u+s <filename>` or `chmod g+s <filename>`  
Uppercase S means execute is not set  
Lowercase s means execute is set  

Sticky bit  
Prevents folder deletion even if a user has write permissions, only the owner can delete  
`chmod +t <filename>`  
Uppercase T means exec is not set  
Lowercase t means exec is set  

You can use numbers to set both of these permissions as well  
chmod 0764 <filename> the first 0 is implied if you only use 3 digits  

```
0 --- --- ---  
1 --- --- --t  
2 --- --s ---  
3 --- --s --t  
4 --s --- ---  
5 --s --- --t  
6 --s --s ---  
7 --s --s --t  
```  

You can change the owner with `chown` and group with `chgrp`  
You can do both with chown if you specify username:group  
Add -R to change the permissions recursively  

`umask` or `umask -S` shows the default permissions when a new file is created.  
You list what you want to suppress from your default files and folders  

**Create and change hard and symbolic links**  
Files are represented by an inode  
Files are only deleted when all links to an inode are removed.  
A hard link is a link to another file's inode, and it can only occur on the same fs.  
A soft link is a link to another file name, and can occur across different fs.  
When you do ls -la the number after the permissions is the number of hard links associated with a file.  
By default, files are 1, and directories are 2 ('.' is a link to itself and '..' is a link to the parent)  
ln is used to make hard links; Example: `ln link1 link2`  
Use ln -s for soft links; Example: `ln -s /usr/bin /somewhere`  
When you run ls on a link, it shows you the destination's contents.  

**Find system files and place files in the correct location**  
`find`, `which`, and `type` can do this  
`find -inum` will search for inode  
`whereis` can show the location of the binary as well as the location of the man page  
`locate` builds a db of your filesystem which can be queried directly instead of searching the fs.  
`updatedb` updates the db used by locate  
`/etc/updatedb.conf` config file that tells locate where not to search  
